---
layout: post
title: The three stages of programming language mastery
---
## Programmatic language aquisition
It dawned on me the other day while talking to someone new to programming that learning a programming language follows steps that mirror human language aquisition. 

First we start by simply parroting. Think of a young child repeating words that his or her parents speak to it. Consider a person with one semester of spanish navigating Mexico city. We start by simply throwing out patterns of words one has memorized. And depending on our luck, get either the responses we are looking for and thus reinforcing the pattern or something completely different which frustrates us. When I taught English as a foreign language, we'd see this behavior in beginners. While the goal was and should be to move beyond mere imitation. I considered it to be better than nothing. At least you're trying at this stage and that puts you in the game. And you cannot succeed at any game you don't even start playing. I did a lot of parroting back when I was learning foreign languages. Looking back I can see how I may have picked up bad habits from mimicking speech patterns that I did not understand. But at least by doing so I steadily began to increase my vocabulary and begin to acquire rudimentary grammar structures and slightly improved pronunciation.  

I would say most programming newbies copy and paste a fair amount of code. Often from tutorials or dubious stackoverflow posts. The problem many newbies, myself included, run into is that we tend to be blissfully unaware of the scale and scope of whatever task we are trying to achieve with our scripts we are trying to build. 

When I first began learning python, spent a lot of time googling big picture question. How to build a website, how to build an AI model, etc. I made the classic novice programmer error of skipping first principles and just jumping head first into the shiny parts. Similarly when I first began learning Serbian and Albanian in the Peace Corps I figured I'd start by diving into films and music in the respective languages. Both reading about how to create Tensorflow models and trying to translate Serbian punk rock were helpful for my language exposure and definitely stretched some mental muscles. But ultimately because I did not understand the basic toolbox of each language, I quickly found myself frustrated and feeling somewhat hopeless. 

What got me back onto the path so to speak was humility. Enough humility to go open the Serbian grammar book and read about python for loops. Aiming big, stumbling, and then returning to first principles is perhaps a necessary stage. I know for myself glimpsing at what I could do with python, gave me the drive and the reason to start from scratch and really nail down the basics. And once you gain the basics, your horizons expand rapidly. 


The next stage is a kind of transition between simply pattern following to manipulation of patterns based on lessons learned from other patterns. You know that you've arrived at this stage when you look at a stackoverflow solution and understand that the post has the information you need but you need to tweak the code a bit to make it work for your use case.Or you begin to see that solution A to one problem can apply to a related problem you've seen elsewhere. 

With more intermediate knowledge of a language both foreign and programming, you also start to specialize in terms of what you need to use the language for. To this day, I still retain a lot of Serbian vocabulary that pertains to rural life and farming in particular. On the other hand my knowledge of terminology relating to urban life is pretty much non-existant. This is because I lived in a rural Serbian community not a city and thus I really did have any use cases for such language.

Similarly most of the experienced programmers I know will readily admit the areas of their favorite language that they do not know. 

The road to mastery, is simply the a granularization of the patterns you've learned and a realization that the patterns are all stacked on top of each other. 
