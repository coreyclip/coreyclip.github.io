---
layout: post
title: The three stages of programming language mastery
published: false
---
## Programmatic language aquisition
It dawned on me the other day while talking to someone new to programming that learning a programming language follows steps that mirror human language aquisition. 

First we start by simply parroting. Think of a young child repeating words that his or her parents speak to it. Consider a person with one semester of spanish navigating Mexico city. We start by simply throwing out patterns of words one has memorized. And depending on our luck, get either the responses we are looking for and thus reinforcing the pattern or something completely different which frustrates us. When I taught English as a foreign language, we'd see this behavior in beginners. While the goal was and should be to move beyond mere imitation. I considered it to be better than nothing. At least you're trying at this stage and that puts you in the game. And you cannot succeed at any game you don't even start playing. I did a lot of parroting back when I was learning foreign languages. Looking back I can see how I may have picked up bad habits from mimicking speech patterns that I did not understand. But at least by doing so I steadily began to increase my vocabulary and begin to acquire rudimentary grammar structures and slightly improved pronunciation.  

I would say most programming newbies copy and paste a fair amount of code. Often from tutorials or dubious stackoverflow posts. The problem many newbies, myself included, run into is that we tend to be blissfully unaware of the scale and scope of whatever task we are trying to achieve with our scripts we are trying to build. 

When I first began learning python, spent a lot of time googling big picture question. How to build a website, how to build an AI model, etc. I made the classic novice programmer error of skipping first principles and just jumping head first into the shiny parts. Similarly when I first began learning Serbian and Albanian in the Peace Corps I figured I'd start by diving into films and music in the respective languages. Both reading about how to create Tensorflow models and trying to translate Serbian punk rock were helpful for my language exposure and definitely stretched some mental muscles. But ultimately because I did not understand the basic toolbox of each language, I quickly found myself frustrated and feeling somewhat hopeless. 

What got me back onto the path so to speak was humility. Enough humility to go open the Serbian grammar book and read about python for loops. Aiming big, stumbling, and then returning to first principles is perhaps a necessary stage. I know for myself glimpsing at what I could do with python, gave me the drive and the reason to start from scratch and really nail down the basics. And once you gain the basics, your horizons expand rapidly. 

The next stage is a kind of transition between simply pattern following to manipulation of patterns based on lessons learned from other patterns. You know that you've arrived at this stage when you look at a stackoverflow solution and understand that the post has the information you need but you need to tweak the code a bit to make it work for your use case.Or you begin to see that solution A to one problem can apply to a related problem you've seen elsewhere. 

With more intermediate knowledge of a language both foreign and programming, you also start to specialize in terms of what you need to use the language for. To this day, I still retain a lot of Serbian vocabulary that pertains to rural life and farming in particular. On the other hand my knowledge of terminology relating to urban life is pretty much non-existant. This is because I lived in a rural Serbian community not a city and thus I really did have any use cases for such language.

In the programming world I mostly work in the realm of data and finance in particular so I'm more on an adept level when it comes to libraries relating to managing and transforming data, while I'm more of beginner in the front-end user experience world. It's very easy to get intimidated by all of the different neat things people are doing in the tech world. And impostor syndrome is something that hangs over even very experienced programmers. I believe the anecdote to that is again a bit of humility and acceptance that by definition expertise in a field, means that sufficient knowledge in the topic is gained and not just expected. And even in areas where we do have experience, most of the experienced programmers I know will readily admit the areas of their favorite language that they do not know. 

Mastery of a human language usually means that you are both able to understand most of the vocabulary and grammar and can therefore begin to play with it. Note that as you move through school your English or foreign language classes typically move beyond just everyday conversation and instead move to material like literature and poetry. As you begin to know the linguistic tools inside and out, you can begin to appreciate consuming and creating more interesting means to utilizing the language. If you've ever tried to understand a comedy or joke written in another language, you can understand how without a background in the language getting the punchline can be near impossible. But if you do make the effort to understand these more abstract forms, your ability to communicate in a manner that will intrigue speakers of that language exponentially increases. I also firmly believe that it gives you more lateral mental strength. Having studied languages in the past, I often think to myself how I'd describe a situation, in a language other than English and I find that it helps me grasp concepts in more abstract terms. 

The road to mastery in acquiring a programming language similarly entails breaking away a bit from established patterns. Mastery entails pushing the bounds of the language and attempting to take it to new and uncharted territories. In this space things get murkier, but you also become wiser. Mastery of a human language revolves around playing with linguistic structure like a poet or great novelist would. Note that most can be absolutely profficient in english without being a published writer or world famous novelist. With a programming language, those with mastery know how to be creative with the language and likely actively push it forward in new directions. Even if you're not contributing to the Linux kernel and writting the next version of python. We can all play at mastery by finding ways to be creative or experiment. It's only by departing into the unknown, that we reach mastery in any given field.  
